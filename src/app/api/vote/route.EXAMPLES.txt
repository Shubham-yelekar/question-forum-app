/**
 * COMPLETE VOTE API TESTING - IMPLEMENTATION EXAMPLE
 * 
 * This shows the actual code pattern for testing your vote API.
 * Copy this as a reference when you implement real tests.
 */

// ============================================================
// STEP 1: MOCKS (Setup before importing the route)
// ============================================================

jest.mock("@/models/server/config", () => ({
  databases: {
    listDocuments: jest.fn(),
    getDocument: jest.fn(),
    createDocument: jest.fn(),
    deleteDocument: jest.fn(),
  },
  users: {
    getPrefs: jest.fn(),
    updatePrefs: jest.fn(),
  },
}));

jest.mock("@/models/name", () => ({
  db: "mock-db",
  voteCollection: "votes",
  questionCollection: "questions",
  answerCollection: "answers",
}));

jest.mock("node-appwrite", () => ({
  ID: {
    unique: () => "unique-id-" + Math.random(),
  },
  Query: {
    equal: (field: string, value: any) => ({ field, value }),
    limit: (n: number) => ({ limit: n }),
  },
  AppwriteException: class AppwriteException extends Error {
    code: number;
    constructor(message: string, code: number = 500) {
      super(message);
      this.code = code;
    }
  },
}));

// ============================================================
// STEP 2: IMPORTS (After mocks)
// ============================================================

import { POST } from "./route";
import { databases, users } from "@/models/server/config";
import { NextRequest } from "next/server";

// ============================================================
// STEP 3: HELPER FUNCTIONS
// ============================================================

/**
 * Creates a mock NextRequest with JSON body
 */
function createMockRequest(body: any) {
  return new NextRequest("http://localhost:3000/api/vote", {
    method: "POST",
    body: JSON.stringify(body),
  });
}

/**
 * Parses response JSON
 */
async function getResponseJson(response: any) {
  return await response.json?.() || response.data;
}

// ============================================================
// STEP 4: TEST SUITE
// ============================================================

describe("Vote API - Complete Implementation Example", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // ────────────────────────────────────────────────────────
  // TEST 1: Create First Upvote
  // ────────────────────────────────────────────────────────
  describe("Create upvote on question", () => {
    test("example: first upvote increases reputation", async () => {
      // STEP 1: Setup input data
      const voteInput = {
        votedById: "user-alice",
        voteStatus: "upvoted",
        type: "question",
        typeId: "q-123",
      };

      // STEP 2: Mock the database check (no existing vote)
      (databases.listDocuments as jest.Mock).mockResolvedValueOnce({
        documents: [],
        total: 0,
      });

      // STEP 3: Mock vote creation
      const newVoteDoc = {
        $id: "vote-id-1",
        ...voteInput,
      };
      (databases.createDocument as jest.Mock).mockResolvedValueOnce(
        newVoteDoc
      );

      // STEP 4: Mock fetching question
      const questionDoc = {
        $id: "q-123",
        title: "How to test?",
        authorId: "author-bob",
      };
      (databases.getDocument as jest.Mock).mockResolvedValueOnce(
        questionDoc
      );

      // STEP 5: Mock getting author's reputation
      (users.getPrefs as jest.Mock).mockResolvedValueOnce({
        reputation: "10", // Bob has 10 rep
      });

      // STEP 6: Mock updating author's reputation
      (users.updatePrefs as jest.Mock).mockResolvedValueOnce({
        reputation: "11", // +1 for upvote
      });

      // STEP 7: Mock vote count queries (for voteResult calculation)
      // First call: count all upvotes
      (databases.listDocuments as jest.Mock).mockResolvedValueOnce({
        documents: [
          { $id: "vote-alice-upvote", voteStatus: "upvoted" },
          { $id: "vote-charlie-upvote", voteStatus: "upvoted" },
        ],
        total: 2,
      });

      // Second call: count all downvotes
      (databases.listDocuments as jest.Mock).mockResolvedValueOnce({
        documents: [{ $id: "vote-dave-downvote", voteStatus: "downvoted" }],
        total: 1,
      });

      // ──────────────────────────────────
      // ACT: Call the API
      // ──────────────────────────────────
      const request = createMockRequest(voteInput);
      const response = await POST(request);

      // ──────────────────────────────────
      // ASSERT: Verify the behavior
      // ──────────────────────────────────

      // 1. Check that vote was created
      expect(databases.createDocument).toHaveBeenCalledWith(
        "mock-db",
        "votes",
        expect.any(String),
        voteInput
      );

      // 2. Check that reputation was updated correctly
      expect(users.updatePrefs).toHaveBeenCalledWith("author-bob", {
        reputation: "11", // Increased by 1
      });

      // 3. Check response status and message
      expect(response.status).toBe(201);
      const json = await getResponseJson(response);
      expect(json.message).toBe("Voted");

      // 4. Check vote result calculation (2 upvotes - 1 downvote = 1)
      expect(json.data.voteResult).toBe(1);
    });
  });

  // ────────────────────────────────────────────────────────
  // TEST 2: Remove Upvote (Click same button again)
  // ────────────────────────────────────────────────────────
  describe("Remove upvote (toggle off)", () => {
    test("example: removing upvote decreases reputation", async () => {
      const voteInput = {
        votedById: "user-alice",
        voteStatus: "upvoted",
        type: "question",
        typeId: "q-123",
      };

      // Alice already upvoted, now she clicks upvote button again
      const existingVote = {
        $id: "vote-id-1",
        voteStatus: "upvoted",
        votedById: "user-alice",
      };

      // MOCK 1: Find existing vote
      (databases.listDocuments as jest.Mock).mockResolvedValueOnce({
        documents: [existingVote],
        total: 1,
      });

      // MOCK 2: Delete the vote
      (databases.deleteDocument as jest.Mock).mockResolvedValueOnce({});

      // MOCK 3: Fetch question
      (databases.getDocument as jest.Mock).mockResolvedValueOnce({
        $id: "q-123",
        authorId: "author-bob",
      });

      // MOCK 4: Get author's reputation (it was 11 after upvote)
      (users.getPrefs as jest.Mock).mockResolvedValueOnce({
        reputation: "11",
      });

      // MOCK 5: Update reputation back to 10
      (users.updatePrefs as jest.Mock).mockResolvedValueOnce({
        reputation: "10", // -1 for removing upvote
      });

      // ──────────────────────────────────
      // ACT
      // ──────────────────────────────────
      const request = createMockRequest(voteInput);
      const response = await POST(request);

      // ──────────────────────────────────
      // ASSERT
      // ──────────────────────────────────

      // 1. Check that vote was deleted
      expect(databases.deleteDocument).toHaveBeenCalledWith(
        "mock-db",
        "votes",
        "vote-id-1"
      );

      // 2. Check that reputation was reverted
      expect(users.updatePrefs).toHaveBeenCalledWith("author-bob", {
        reputation: "10", // Back to original
      });

      // 3. Response should be 200 (no new document)
      expect(response.status).toBe(200);
      const json = await getResponseJson(response);
      expect(json.message).toBe("vote handled");
      expect(json.data.document).toBeNull();
    });
  });

  // ────────────────────────────────────────────────────────
  // TEST 3: Change Vote (Upvote → Downvote)
  // ────────────────────────────────────────────────────────
  describe("Change vote from upvote to downvote", () => {
    test("example: changing upvote to downvote", async () => {
      const voteInput = {
        votedById: "user-alice",
        voteStatus: "downvoted", // Different from existing upvote!
        type: "question",
        typeId: "q-123",
      };

      // Alice had upvoted, now she's clicking downvote
      const existingUpvote = {
        $id: "vote-id-1",
        voteStatus: "upvoted",
        votedById: "user-alice",
      };

      // MOCK 1: Find existing upvote
      (databases.listDocuments as jest.Mock).mockResolvedValueOnce({
        documents: [existingUpvote],
        total: 1,
      });

      // Since vote status changed (upvoted !== downvoted):
      // Step 1: Delete old upvote
      (databases.deleteDocument as jest.Mock).mockResolvedValueOnce({});

      // MOCK 2: Fetch question (after delete)
      (databases.getDocument as jest.Mock)
        .mockResolvedValueOnce({ $id: "q-123", authorId: "author-bob" }) // After delete
        .mockResolvedValueOnce({ $id: "q-123", authorId: "author-bob" }); // After create

      // MOCK 3: Get reputation (after delete) = 11
      (users.getPrefs as jest.Mock)
        .mockResolvedValueOnce({ reputation: "11" }) // After delete
        .mockResolvedValueOnce({ reputation: "10" }); // After create

      // MOCK 4: Update reputation (delete -1)
      (users.updatePrefs as jest.Mock)
        .mockResolvedValueOnce({ reputation: "10" }) // Delete: -1
        .mockResolvedValueOnce({ reputation: "9" }); // Create: -1

      // MOCK 5: Create new downvote
      (databases.createDocument as jest.Mock).mockResolvedValueOnce({
        $id: "vote-id-2",
        ...voteInput,
      });

      // ──────────────────────────────────
      // ACT
      // ──────────────────────────────────
      const request = createMockRequest(voteInput);
      const response = await POST(request);

      // ──────────────────────────────────
      // ASSERT
      // ──────────────────────────────────

      // 1. Check that old vote was deleted
      expect(databases.deleteDocument).toHaveBeenCalled();

      // 2. Check that new vote was created
      expect(databases.createDocument).toHaveBeenCalledWith(
        "mock-db",
        "votes",
        expect.any(String),
        voteInput
      );

      // 3. Check that reputation was updated twice (delete + create = -2)
      expect(users.updatePrefs).toHaveBeenCalledTimes(2);

      // 4. Response status should be 201 (new vote)
      expect(response.status).toBe(201);
      const json = await getResponseJson(response);
      expect(json.message).toBe("Vote Status Updated");
    });
  });

  // ────────────────────────────────────────────────────────
  // TEST 4: Error Handling
  // ────────────────────────────────────────────────────────
  describe("Error handling", () => {
    test("example: handles database errors", async () => {
      const voteInput = {
        votedById: "user-alice",
        voteStatus: "upvoted",
        type: "question",
        typeId: "q-123",
      };

      // MOCK: Database throws error
      (databases.listDocuments as jest.Mock).mockRejectedValueOnce(
        new Error("Connection timeout")
      );

      // ──────────────────────────────────
      // ACT
      // ──────────────────────────────────
      const request = createMockRequest(voteInput);
      const response = await POST(request);

      // ──────────────────────────────────
      // ASSERT
      // ──────────────────────────────────
      expect(response.status).toBe(500);
      const json = await getResponseJson(response);
      expect(json.message).toContain("Connection timeout");
    });
  });
});
